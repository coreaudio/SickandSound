<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Hausdienst</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0e14" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="stylesheet" href="style.css" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800&display=swap" rel="stylesheet" />
  <style>
    .tabs { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
    .tabs .tabbtn { padding:8px 12px; border-radius:999px; background:#1c2130; color:#e6e8ef; border:1px solid #2a3042; }
    .tabs .tabbtn.active { background:linear-gradient(135deg,#6ee7ff,#a78bfa); color:#0b0e14; border-color:transparent; font-weight:800; }
    .panel { display:none; }
    .panel.active { display:block; }

    .people-row { display:flex; gap:8px; overflow-x:auto; padding-bottom:4px; scrollbar-width:thin; }
    .people-row .pill { flex:0 0 auto; padding:8px 12px; border-radius:999px; background:#1c2130; border:1px solid #2a3042; color:#e6e8ef; }
    .people-row .pill.active { background:linear-gradient(135deg,#6ee7ff,#a78bfa); color:#0b0e14; border-color:transparent; font-weight:800; }

    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .badge.big { font-size:14px; padding:6px 10px; }
    .muted { opacity:.7 }

    .segmented { display:flex; gap:8px; flex-wrap:wrap; }
    .segmented .tabbtn { padding:8px 12px; border-radius:999px; background:#1c2130; color:#e6e8ef; border:1px solid #2a3042; }
    .segmented .tabbtn.active { background:linear-gradient(135deg,#6ee7ff,#a78bfa); color:#0b0e14; border-color:transparent; font-weight:800; }

    .toolbar { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    .toolbar input, .toolbar select { flex:1 1 auto; min-width:160px; }
    .groupTitle { font-weight:800; letter-spacing:.2px; margin:6px 0 6px; }

    /* Neues Checklisten-Design */
    .status-header-card { padding: 16px; }
    .status-header { display: flex; justify-content: space-between; align-items: center; }
    .status-left { flex: 1; }
    .status-person { font-size: 22px; font-weight: 800; }
    .status-person.none { opacity: 0.5; font-size: 16px; }
    .status-date { font-size: 12px; opacity: 0.6; margin-top: 2px; }

    /* Progress Ring */
    .progress-ring { width: 70px; height: 70px; position: relative; }
    .progress-ring svg { transform: rotate(-90deg); width: 100%; height: 100%; }
    .ring-bg { fill: none; stroke: #2a3042; stroke-width: 3; }
    .ring-fill { fill: none; stroke: url(#progressGradient); stroke-width: 3; stroke-linecap: round; transition: stroke-dasharray 0.3s; }
    .progress-text { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 800; }
    .progress-ring.done .ring-fill { stroke: #7CFC9A; }
    .progress-ring.done .progress-text { color: #7CFC9A; }

    /* Task-Liste */
    .task-card { padding: 0; overflow: hidden; }
    .task-header { padding: 12px 16px; border-bottom: 1px solid #2a3042; background: #151a23; }
    .hide-done-toggle { display: flex; align-items: center; gap: 8px; font-size: 13px; cursor: pointer; opacity: 0.8; }
    .hide-done-toggle input { width: 18px; height: 18px; cursor: pointer; }
    .task-list { max-height: calc(100vh - 420px); overflow-y: auto; }

    /* Kategorie-Gruppen */
    .task-group { margin-bottom: 0; }
    .task-group-header { padding: 10px 16px 6px; font-size: 11px; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; color: #6ee7ff; background: #151a23; position: sticky; top: 0; z-index: 1; }

    /* Einzelne Task */
    .task-item { display: flex; align-items: center; padding: 14px 16px; border-bottom: 1px solid #1c2130; transition: background 0.2s, transform 0.2s; cursor: grab; }
    .task-item:active { cursor: grabbing; }
    .task-item.done { opacity: 0.5; }
    .task-item.done .task-text { text-decoration: line-through; }
    .task-item.dragging { opacity: 0.5; background: #2a3042; transform: scale(1.02); }
    .task-item.drag-over { border-top: 3px solid #6ee7ff; }
    .task-item.touch-dragging { position: relative; z-index: 100; background: #2a3042; box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
    .drag-handle { padding: 8px; margin-right: 4px; opacity: 0.4; cursor: grab; font-size: 16px; touch-action: none; }
    .task-item:hover .drag-handle { opacity: 0.8; }
    @media (pointer: coarse) { .drag-handle { opacity: 0.6; padding: 10px; } }
    .task-checkbox { width: 26px; height: 26px; border-radius: 50%; border: 2px solid #3a4052; background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.2s; }
    .task-checkbox:hover { border-color: #6ee7ff; }
    .task-checkbox.checked { background: linear-gradient(135deg, #6ee7ff, #7CFC9A); border-color: transparent; }
    .task-checkbox.checked::after { content: '‚úì'; color: #0b0e14; font-weight: 800; font-size: 14px; }
    .task-content { flex: 1; margin-left: 12px; min-width: 0; cursor: pointer; }
    .task-text { font-size: 15px; line-height: 1.3; }
    .task-actions { display: flex; gap: 4px; margin-left: 8px; opacity: 0; transition: opacity 0.2s; }
    .task-item:hover .task-actions { opacity: 1; }
    @media (pointer: coarse) { .task-actions { opacity: 1; } }
    .task-action-btn { width: 32px; height: 32px; border-radius: 8px; border: none; background: transparent; color: #6ee7ff; cursor: pointer; font-size: 14px; }
    .task-action-btn:hover { background: rgba(110, 231, 255, 0.1); }

    /* Aufgabe hinzuf√ºgen */
    .add-task-card { padding: 12px 16px; }
    .add-task-row { display: flex; gap: 10px; }
    .add-task-row input { flex: 1; padding: 12px 14px; border-radius: 10px; border: 1px solid #2a3042; background: #0e1422; color: #e6e8ef; font-size: 15px; }
    .add-task-row input:focus { border-color: #6ee7ff; outline: none; }
    .add-btn { width: 46px; height: 46px; border-radius: 10px; font-size: 24px; font-weight: 400; padding: 0; }

    /* Complete Button */
    .complete-btn { width: 100%; padding: 14px; font-size: 15px; }
    .complete-btn:disabled { background: #2a3042; color: #666; cursor: not-allowed; opacity: 0.6; }
    .complete-btn.done { background: #7CFC9A; pointer-events: none; }

    /* Edit Task Modal */
    .edit-task-input { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #2a3042; background: #0e1422; color: #e6e8ef; font-size: 15px; margin-bottom: 10px; }
    .edit-task-input:focus { border-color: #6ee7ff; outline: none; }
    .edit-task-select { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #2a3042; background: #0e1422; color: #e6e8ef; font-size: 14px; margin-bottom: 15px; }

    /* 6-Monats-√úbersicht */
    .table-scroll { overflow-x: auto; margin: 0 -16px; padding: 0 16px; }
    .overview-table { width: 100%; border-collapse: collapse; font-size: 13px; min-width: 600px; }
    .overview-table th, .overview-table td { padding: 10px 8px; text-align: center; border-bottom: 1px solid #2a3042; white-space: nowrap; }
    .overview-table th { background: #151a23; font-weight: 800; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; position: sticky; top: 0; }
    .overview-table th:first-child { text-align: left; min-width: 80px; }
    .overview-table td:first-child { text-align: left; font-weight: 600; }
    .overview-table tbody tr:hover { background: rgba(110, 231, 255, 0.05); }
    .overview-table .count-cell { font-weight: 800; }
    .overview-table .count-cell.zero { opacity: 0.3; }
    .overview-table .count-cell.good { color: #7CFC9A; }
    .overview-table .count-cell.warn { color: #ff9f43; }
    .overview-table .count-cell.bad { color: #ff6b6b; }
    .overview-table tfoot td { font-weight: 800; background: #1c2130; border-top: 2px solid #3a4052; }

    .statusdot{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:6px;background:#ffadad}
    .statusok{background:#7CFC9A}

    /* Drag & Drop */
    .task-item { cursor: grab; transition: background 0.2s, transform 0.2s; user-select: none; -webkit-user-select: none; }
    .task-item:active { cursor: grabbing; }
    .task-item.dragging { opacity: 0.5; background: #2a3042; transform: scale(1.02); }
    .task-item.drag-over { border-top: 3px solid #6ee7ff; }
    .drag-handle {
      cursor: grab;
      padding: 8px 12px;
      opacity: 0.4;
      touch-action: none;
      font-size: 18px;
      border-radius: 6px;
      transition: opacity 0.2s, background 0.2s;
    }
    .drag-handle:hover { opacity: 1; background: rgba(110, 231, 255, 0.1); }
    @media (pointer: coarse) {
      /* Touch-Ger√§te: gr√∂√üerer Tap-Bereich */
      .drag-handle {
        padding: 12px 14px;
        opacity: 0.6;
        background: rgba(110, 231, 255, 0.05);
      }
    }
    .task-item.touch-dragging { position: relative; z-index: 100; background: #2a3042; box-shadow: 0 4px 12px rgba(0,0,0,0.4); }

    /* Bewertungssystem */
    .rating-section { margin-top: 15px; padding: 15px; background: #1c2130; border-radius: 12px; border: 1px solid #2a3042; }
    .star-rating { display: flex; gap: 8px; margin: 10px 0; }
    .star-rating .star { font-size: 28px; cursor: pointer; color: #2a3042; transition: color 0.2s, transform 0.2s; }
    .star-rating .star:hover, .star-rating .star.active { color: #ffd700; transform: scale(1.1); }
    .star-rating .star.hovered { color: #ffd700; }
    .rating-comment { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #2a3042; background: #0e1422; color: #e6e8ef; resize: vertical; min-height: 60px; }
    .rating-info { font-size: 12px; opacity: 0.7; margin-bottom: 8px; }
    .rating-preview { display: flex; align-items: center; gap: 4px; }
    .rating-preview .star { color: #ffd700; }
    .rating-preview .star.empty { color: #2a3042; }

    /* Hausdienst Status */
    .hd-status { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; border-radius: 8px; font-size: 12px; }
    .hd-status.pending { background: rgba(255, 107, 107, 0.2); color: #ff6b6b; }
    .hd-status.complete { background: rgba(124, 252, 154, 0.2); color: #7CFC9A; }
    .progress-bar { height: 4px; background: #2a3042; border-radius: 2px; overflow: hidden; margin-top: 6px; }
    .progress-bar .fill { height: 100%; background: linear-gradient(90deg, #6ee7ff, #7CFC9A); transition: width 0.3s; }

    /* Admin-Modus */
    .admin-indicator { background-color: #ff6b6b; padding: 4px 8px; border-radius: 4px; margin-left: 8px; font-size: 12px; }
    .admin-card { background: rgba(255, 107, 107, 0.1); border: 1px solid rgba(255, 107, 107, 0.3); }
    .admin-form { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
    .admin-form .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .admin-form input[type="date"] { padding: 8px 12px; border-radius: 8px; border: 1px solid #2a3042; background: #0e1422; color: #e6e8ef; }
    .admin-form select { padding: 8px 12px; border-radius: 8px; border: 1px solid #2a3042; background: #0e1422; color: #e6e8ef; flex: 1; min-width: 120px; }

    /* Bewertungs-Modal */
    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; place-items: center; z-index: 100; padding: 20px; }
    .modal.show { display: grid; }
    .modal-box { background: #151a23; border-radius: 16px; padding: 24px; max-width: 400px; width: 100%; border: 1px solid #2a3042; }
    .modal-title { font-size: 18px; font-weight: 800; margin-bottom: 8px; }
    .modal-stars { display: flex; gap: 8px; justify-content: center; margin: 20px 0; }
    .modal-stars .star { font-size: 36px; cursor: pointer; color: #2a3042; transition: all 0.2s; }
    .modal-stars .star:hover, .modal-stars .star.active { color: #ffd700; transform: scale(1.15); }
    .modal-stars .star.hovered { color: #ffd700; }
    .modal-actions { display: flex; gap: 10px; margin-top: 15px; }
    .modal-actions .btn { flex: 1; }

    /* Warnung bei unvollst√§ndigen Aufgaben */
    .incomplete-warning {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 14px 16px;
      margin-top: 12px;
      background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 165, 0, 0.15));
      border: 2px solid #ff6b6b;
      border-radius: 12px;
      animation: warningPulse 2s ease-in-out infinite;
    }
    @keyframes warningPulse {
      0%, 100% { border-color: #ff6b6b; box-shadow: 0 0 0 0 rgba(255, 107, 107, 0); }
      50% { border-color: #ff9f43; box-shadow: 0 0 15px 2px rgba(255, 107, 107, 0.3); }
    }
    .warning-icon { font-size: 28px; line-height: 1; }
    .warning-text { flex: 1; }
    .warning-text strong { display: block; color: #ff6b6b; font-size: 14px; margin-bottom: 4px; }
    .warning-text span { font-size: 12px; opacity: 0.9; }

    /* Abschluss-Button */
    .complete-btn {
      width: 100%;
      padding: 14px 20px;
      font-size: 16px;
      font-weight: 800;
      background: linear-gradient(135deg, #6ee7ff, #7CFC9A);
      color: #0b0e14;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .complete-btn:disabled {
      background: #2a3042;
      color: #666;
      cursor: not-allowed;
      opacity: 0.6;
    }
    .complete-btn:not(:disabled):hover {
      transform: scale(1.02);
      box-shadow: 0 4px 20px rgba(110, 231, 255, 0.4);
    }
    .complete-btn.completed {
      background: #7CFC9A;
      pointer-events: none;
    }
  </style>
</head>
<body>
<div class="app">
  <header class="appbar">
    <div class="app-title">
      <div class="brand-dot"></div>
      <h1>Hausdienst</h1>
      <span id="adminIndicator" class="admin-indicator" style="display:none;">Admin</span>
    </div>
    <div class="appbar-actions">
      <button class="btn small warning" id="adminBtn" onclick="toggleAdminMode()" title="Admin-Modus">üîß</button>
      <a class="btn small dark" href="index.html" title="Zur Liste">üßæ</a>
    </div>
  </header>

  <main class="content">
    <div class="card">
      <div class="section-title">Heute</div>
      <div id="todayInfo" class="sub">Lade‚Ä¶</div>
      <div class="tabs" style="margin-top:10px">
        <button id="tabCheck" class="tabbtn active" onclick="showTab('check')">Checkliste</button>
        <button id="tabPlan" class="tabbtn" onclick="showTab('plan')">Planen</button>
        <button id="tabHist" class="tabbtn" onclick="showTab('history')">Historie</button>
      </div>
      <div class="sub" id="connInfo" style="margin-top:6px"><span class="statusdot" id="dot"></span><span id="connTxt">Verbinde‚Ä¶</span></div>
    </div>

    <!-- Panel: Planen -->
    <div id="panelPlan" class="panel">
      <!-- Admin: R√ºckwirkend eintragen -->
      <div class="card admin-card" id="adminPanel" style="display:none">
        <div class="section-title">Admin: R√ºckwirkend eintragen</div>
        <div class="sub">Hausdienst f√ºr beliebiges Datum eintragen oder √§ndern</div>
        <div class="admin-form">
          <div class="row">
            <input type="date" id="adminDate" />
            <select id="adminPerson">
              <option value="">Person ausw√§hlen...</option>
            </select>
          </div>
          <div class="row">
            <button class="btn small" onclick="adminSetHausdienst()">Eintragen</button>
            <button class="btn small warning" onclick="adminClearHausdienst()">L√∂schen</button>
            <label style="display:flex;align-items:center;gap:6px;font-size:12px">
              <input type="checkbox" id="adminMarkComplete" /> Als abgeschlossen markieren
            </label>
          </div>
        </div>
        <div id="adminStatus" class="sub" style="margin-top:8px"></div>
      </div>

      <div class="card">
        <div class="section-title">Hausdienst planen</div>
        <div class="row" style="margin-top:6px">
          <button id="btnToday" class="btn small" onclick="setFor('today')" disabled>Heute belegen</button>
          <button id="btnTomorrow" class="btn small" onclick="setFor('tomorrow')" disabled>Morgen belegen</button>
          <span id="selBadge" class="badge big">Auswahl: ‚Äì</span>
        </div>
      </div>

      <div class="card">
        <div class="section-title">Person ausw√§hlen</div>
        <div id="peopleRow" class="people-row" style="margin-top:8px"></div>
        <div class="sub muted" style="margin-top:6px">
          Tipp: Person w√§hlen, dann ‚ÄûHeute/Morgen‚Äú oder unten in der Liste ‚ÄûBelegen‚Äú tippen.
        </div>
      </div>

      <div class="card table-wrap">
        <div class="section-title">Geplante Hausdienste (n√§chste 14 Tage)</div>
        <div id="nextList" class="sub">Lade‚Ä¶</div>
      </div>
    </div>

    <!-- Panel: Checkliste -->
    <div id="panelCheck" class="panel active">
      <!-- Status-Header -->
      <div class="card status-header-card">
        <div class="status-header">
          <div class="status-left">
            <div class="status-person" id="hdPersonName">‚Äî</div>
            <div class="status-date" id="hdDate"></div>
          </div>
          <div class="status-right">
            <div class="progress-ring" id="progressRing">
              <svg viewBox="0 0 36 36">
                <defs>
                  <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#6ee7ff"/>
                    <stop offset="100%" stop-color="#a78bfa"/>
                  </linearGradient>
                </defs>
                <path class="ring-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"/>
                <path class="ring-fill" id="ringFill" stroke-dasharray="0, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"/>
              </svg>
              <div class="progress-text" id="progressText">0/0</div>
            </div>
          </div>
        </div>
        <button class="btn complete-btn" id="completeHdBtn" onclick="completeHausdienst()" disabled style="margin-top:12px">
          ‚úì Hausdienst abschlie√üen
        </button>
      </div>

      <!-- Task-Liste -->
      <div class="card task-card">
        <div class="task-header">
          <label class="hide-done-toggle">
            <input type="checkbox" id="hideDone" onchange="toggleHideDone()">
            <span>Erledigte ausblenden</span>
          </label>
        </div>
        <div id="taskList" class="task-list">Lade Aufgaben‚Ä¶</div>
      </div>

      <!-- Aufgabe hinzuf√ºgen -->
      <div class="card add-task-card">
        <div class="add-task-row">
          <input id="newTask" placeholder="Neue Aufgabe‚Ä¶" onkeypress="if(event.key==='Enter')addTask()">
          <button class="btn add-btn" onclick="addTask()">+</button>
        </div>
      </div>

      <!-- Bewertung -->
      <div class="card" id="ratingCard" style="display:none">
        <button class="btn small ghost" onclick="openRatingModal()" id="openRatingBtn">‚≠ê Gestrigen Hausdienst bewerten</button>
      </div>
    </div>

    <!-- Panel: Historie -->
    <div id="panelHist" class="panel">
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center">
          <div class="section-title" style="margin:0">Hausdienst ‚Äì Historie</div>
          <a href="bewertungen.html" class="btn small">Alle Bewertungen</a>
        </div>
      </div>

      <!-- 6-Monats-√úbersicht -->
      <div class="card">
        <div class="section-title">√úbersicht letzte 6 Monate</div>
        <div class="sub" style="margin-bottom:10px">Hausdienste pro Person und Monat (Wochenende = 0.5)</div>
        <div class="table-scroll">
          <table class="overview-table" id="monthlyOverview">
            <thead><tr><th>Monat</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="card table-wrap">
        <div class="section-title">Letzte 30 Tage</div>
        <div id="histList" class="sub">Lade‚Ä¶</div>
      </div>
    </div>
  </main>

  <nav class="bottomnav">
    <a class="tab" href="index.html">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M4 6h16v2H4zM4 11h16v2H4zM4 16h10v2H4z"/></svg>
      <span>Liste</span>
    </a>
    <a class="tab active" href="hausdienst.html">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 3l9 7-1.2 1.6L18 10.1V20h-5v-6H11v6H6v-9.9L4.2 11.6 3 10z"/></svg>
      <span>Hausdienst</span>
    </a>
    <a class="tab" href="hausdienst.html#check" style="display:none"></a><!-- Reserve -->
    <a class="tab" href="rangliste.html">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M7 17H3V7h4v10zm7 0h-4V3h4v14zm7 0h-4v-8h4v8z"/></svg>
      <span>Rang</span>
    </a>
    <a class="tab" href="bewertungen.html">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 1l3.09 6.26L22 8.27l-5 4.87L18.18 22 12 18.56 5.82 22 7 13.14 2 8.27l6.91-1.01L12 1z"/></svg>
      <span>Bewertungen</span>
    </a>
    <a class="tab" href="buchungen.html">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 2h9l5 5v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 0 0 1 2-2zm8 1.5V8h4.5L14 3.5z"/></svg>
      <span>Buchungen</span>
    </a>
  </nav>
</div>

<!-- Task-Bearbeiten-Modal -->
<div class="modal" id="editTaskModal">
  <div class="modal-box">
    <div class="modal-title">Aufgabe bearbeiten</div>
    <input type="text" id="editTaskText" class="edit-task-input" placeholder="Aufgabentext...">
    <select id="editTaskCat" class="edit-task-select">
      <option value="morgens">Morgens</option>
      <option value="tag">Im Laufe des Tages</option>
      <option value="abend">Bevor man geht</option>
    </select>
    <div class="modal-actions">
      <button class="btn" onclick="saveTaskEdit()">Speichern</button>
      <button class="btn danger" onclick="deleteTaskFromModal()">L√∂schen</button>
      <button class="btn ghost" onclick="closeEditTaskModal()">Abbrechen</button>
    </div>
  </div>
</div>

<!-- Abschluss-Modal -->
<div class="modal" id="completionModal">
  <div class="modal-box">
    <div class="modal-title">üéâ Alle Aufgaben erledigt!</div>
    <div class="sub" style="margin:15px 0">Du hast alle Hausdienst-Aufgaben f√ºr heute erledigt. M√∂chtest du den Hausdienst jetzt abschlie√üen?</div>
    <div class="modal-actions">
      <button class="btn" onclick="confirmCompletion()">‚úì Hausdienst abschlie√üen</button>
      <button class="btn ghost" onclick="closeCompletionModal()">Sp√§ter</button>
    </div>
  </div>
</div>

<!-- Planungs-Modal f√ºr n√§chsten Tag -->
<div class="modal" id="planNextModal">
  <div class="modal-box">
    <div class="modal-title">üìÖ Hausdienst f√ºr morgen planen</div>
    <div class="sub" style="margin:10px 0" id="planNextInfo">W√§hle eine Person f√ºr den Hausdienst morgen:</div>
    <div id="planNextPeopleList" style="display:flex;flex-wrap:wrap;gap:8px;margin:15px 0"></div>
    <div class="modal-actions">
      <button class="btn ghost" onclick="closePlanNextModal()">√úberspringen</button>
    </div>
  </div>
</div>

<!-- Bewertungs-Modal -->
<div class="modal" id="ratingModal">
  <div class="modal-box">
    <div class="modal-title">Hausdienst bewerten</div>
    <div id="modalRatingInfo" class="sub"></div>
    <div class="modal-stars" id="modalStars">
      <span class="star" data-value="1" onclick="setModalRating(1)" onmouseenter="hoverModalRating(1)" onmouseleave="hoverModalRating(0)">‚òÖ</span>
      <span class="star" data-value="2" onclick="setModalRating(2)" onmouseenter="hoverModalRating(2)" onmouseleave="hoverModalRating(0)">‚òÖ</span>
      <span class="star" data-value="3" onclick="setModalRating(3)" onmouseenter="hoverModalRating(3)" onmouseleave="hoverModalRating(0)">‚òÖ</span>
      <span class="star" data-value="4" onclick="setModalRating(4)" onmouseenter="hoverModalRating(4)" onmouseleave="hoverModalRating(0)">‚òÖ</span>
      <span class="star" data-value="5" onclick="setModalRating(5)" onmouseenter="hoverModalRating(5)" onmouseleave="hoverModalRating(0)">‚òÖ</span>
    </div>
    <textarea id="modalComment" class="rating-comment" placeholder="Optionaler Kommentar..."></textarea>
    <div class="modal-actions">
      <button class="btn" id="modalSubmitBtn" onclick="submitModalRating()" disabled>Bewerten</button>
      <button class="btn ghost" onclick="closeRatingModal()">Sp√§ter</button>
    </div>
  </div>
</div>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/12.0.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/12.0.0/firebase-analytics-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore-compat.js"></script>
<script>
  const DEFAULT_CORE=["Chris","Daniel","Elmi","Florian","Joel","Kevin","Kiste","Marco","Meli","Simon"];
  let CORE=[...DEFAULT_CORE]; // Wird dynamisch aus Firebase geladen
  const ADMIN_PASSWORD = "1379";
  let adminMode = false;
  const STATE_COLLECTION = location.search.includes("beta") ? "state_beta" : "state";

  /* ‚úÖ Richtiges Firebase-Config f√ºr sickandsound-8a15f */
  const firebaseConfig = {
    apiKey: "AIzaSyBtZsr4QPHQbvO2qae6MoBoxJF5dNP2vh0",
    authDomain: "sickandsound-8a15f.firebaseapp.com",
    projectId: "sickandsound-8a15f",
    storageBucket: "sickandsound-8a15f.appspot.com",
    messagingSenderId: "32138160959",
    appId: "1:32138160959:web:a65c7f4ad7d44e757fc18a"
  };

  let db=null;
  try{
    if(window.firebase){
      firebase.initializeApp(firebaseConfig);
      try{firebase.analytics();}catch(_){}
      db=firebase.firestore();

      /* üõú Long-Polling f√ºr mobile Netze */
      try { db.settings({ experimentalAutoDetectLongPolling:true, merge:true }); } catch(_) {}

      document.getElementById('dot').classList.add('statusok');
      document.getElementById('connTxt').textContent='Online (Firestore verbunden)';
    }
  }catch(e){
    db=null;
    document.getElementById('connTxt').textContent='Offline ‚Äì Firebase konnte nicht initialisiert werden.';
  }

  /* üîé Diagnose ‚Äì zeigt sofort Projekt & Zugriff */
  async function diagFirestore(){
    const el = document.getElementById('todayInfo');
    el.textContent = 'Teste Firestore‚Ä¶ (Project: ' + (firebase.app()?.options?.projectId||'?') + ')';
    try {
      const test = await db.collection('hausdienst').limit(1).get();
      el.textContent = 'Firestore OK (' + test.size + ' Docs gefunden) ‚Äì Project: ' + firebase.app().options.projectId;
    } catch(e) {
      el.textContent = 'Firestore-Fehler: ' + (e.code || e.message) + ' ‚Äì Project: ' + (firebase.app()?.options?.projectId||'?');
      console.error('Diag:', e);
    }
  }
  diagFirestore();

  /* Tabs */
  function showTab(key){
    const map={plan:'panelPlan', check:'panelCheck', history:'panelHist'};
    ['plan','check','history'].forEach(k=>{
      document.getElementById(map[k]).classList.toggle('active', k===key);
      document.getElementById('tab'+(k==='history'?'Hist':k.charAt(0).toUpperCase()+k.slice(1))).classList.toggle('active', k===key);
    });
    // Hash synchronisieren (check = leerer Hash, da Checkliste der Standard ist)
    if(history.pushState){
      const h = key==='check' ? '' : '#'+key;
      history.replaceState(null,'', location.pathname + (h? h : ''));
    }

    // Bei Wechsel zur Checkliste: Bewertungs-Modal pr√ºfen
    if (key === 'check') {
      checkAndShowRatingModal();
    }
  }

  // Nur Query/Hash ‚Äì KEIN localStorage
  function pickTabFromQuery(){
    let t = new URLSearchParams(location.search).get('tab');
    if(!t){
      const hash=(location.hash||'').replace('#','');
      if(['check','history','plan'].includes(hash)) t = hash;
    }
    showTab(t || 'check');
  }
  window.addEventListener('hashchange', pickTabFromQuery);

  /* Datum & Refresh */
  const todayStr=()=>new Date().toISOString().slice(0,10);
  function scheduleMidnightRefresh(cb){
    const now=new Date();
    const mid=new Date(now.getFullYear(),now.getMonth(),now.getDate()+1,0,0,2);
    setTimeout(()=>{ cb(); scheduleMidnightRefresh(cb); }, mid-now);
  }

  /* Admin-Modus */
  function toggleAdminMode() {
    if (adminMode) {
      adminMode = false;
      document.getElementById('adminIndicator').style.display = 'none';
      document.getElementById('adminPanel').style.display = 'none';
      document.getElementById('adminBtn').textContent = 'üîß';
      return;
    }

    const password = prompt("Admin-Passwort eingeben:");
    if (password === ADMIN_PASSWORD) {
      adminMode = true;
      document.getElementById('adminIndicator').style.display = 'inline-block';
      document.getElementById('adminPanel').style.display = 'block';
      document.getElementById('adminBtn').textContent = 'üîß‚úì';
      initAdminPanel();
    } else {
      alert("Falsches Passwort");
    }
  }

  function initAdminPanel() {
    // Datum auf heute setzen
    document.getElementById('adminDate').value = todayStr();

    // Personen-Dropdown f√ºllen
    const select = document.getElementById('adminPerson');
    select.innerHTML = '<option value="">Person ausw√§hlen...</option>';
    CORE.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p;
      opt.textContent = p;
      select.appendChild(opt);
    });
  }

  async function adminSetHausdienst() {
    if (!adminMode || !db) return;

    const date = document.getElementById('adminDate').value;
    const person = document.getElementById('adminPerson').value;
    const markComplete = document.getElementById('adminMarkComplete').checked;
    const statusEl = document.getElementById('adminStatus');

    if (!date || !person) {
      statusEl.innerHTML = '<span class="badge" style="background:#ff6b6b;color:#fff">Bitte Datum und Person ausw√§hlen</span>';
      return;
    }

    try {
      const data = {
        person: person,
        updatedAt: Date.now(),
        setByAdmin: true
      };

      if (markComplete) {
        data.completed = true;
        data.completedAt = Date.now();
      }

      await db.collection("hausdienst").doc(date).set(data, { merge: true });
      statusEl.innerHTML = `<span class="badge ok">‚úì ${person} f√ºr ${date} eingetragen${markComplete ? ' (abgeschlossen)' : ''}</span>`;

      // Listen aktualisieren
      if (date === todayStr()) await updateTodayInfo();
      await renderNextDays();
      await renderHistory();
    } catch (e) {
      statusEl.innerHTML = `<span class="badge" style="background:#ff6b6b;color:#fff">Fehler: ${e.message}</span>`;
    }
  }

  async function adminClearHausdienst() {
    if (!adminMode || !db) return;

    const date = document.getElementById('adminDate').value;
    const statusEl = document.getElementById('adminStatus');

    if (!date) {
      statusEl.innerHTML = '<span class="badge" style="background:#ff6b6b;color:#fff">Bitte Datum ausw√§hlen</span>';
      return;
    }

    if (!confirm(`Hausdienst f√ºr ${date} wirklich l√∂schen?`)) return;

    try {
      await db.collection("hausdienst").doc(date).delete();
      statusEl.innerHTML = `<span class="badge ok">‚úì Hausdienst f√ºr ${date} gel√∂scht</span>`;

      // Listen aktualisieren
      if (date === todayStr()) await updateTodayInfo();
      await renderNextDays();
      await renderHistory();
    } catch (e) {
      statusEl.innerHTML = `<span class="badge" style="background:#ff6b6b;color:#fff">Fehler: ${e.message}</span>`;
    }
  }

  /* Auswahl */
  let selectedPerson=null;

  function renderPeopleRow(){
    const wrap=document.getElementById('peopleRow');
    wrap.innerHTML = CORE.map(p=>`<button class="pill ${selectedPerson===p?'active':''}" onclick="selectPerson('${p}')">${p}</button>`).join("");
  }
  function updateSelectionUI(){
    const badge=document.getElementById('selBadge');
    const has=!!selectedPerson;
    badge.innerHTML = has ? `Auswahl: <b>${selectedPerson}</b>` : "Auswahl: ‚Äì";
    document.getElementById('btnToday').disabled = !has;
    document.getElementById('btnTomorrow').disabled = !has;
  }
  function selectPerson(name){
    if(!CORE.includes(name)) return;
    selectedPerson = (selectedPerson===name ? null : name);
    renderPeopleRow(); updateSelectionUI(); renderNextDays();
  }

  /* Setzen/L√∂schen */
  async function setFor(day){
    if(!selectedPerson) return alert("Bitte zuerst eine Person ausw√§hlen.");
    if(!db) return alert("Offline ‚Äì kann nicht speichern.");
    const dt=new Date(); if(day==='tomorrow') dt.setDate(dt.getDate()+1);
    const id=dt.toISOString().slice(0,10);
    const ex=await db.collection("hausdienst").doc(id).get();
    if(ex.exists && ex.data().person){ alert(`Bereits belegt: ${ex.data().person}. Bitte in der √úbersicht austragen.`); return; }
    await db.collection("hausdienst").doc(id).set({person:selectedPerson, updatedAt:Date.now()});
    if(id===todayStr()) await updateTodayInfo();
    await renderNextDays(); await renderHistory();
  }
  async function setForDate(date, person){
    if(!db) return alert("Offline ‚Äì kann nicht speichern.");
    const ex=await db.collection("hausdienst").doc(date).get();
    if(exists(ex)){ alert(`Bereits belegt: ${ex.data().person}`); return; }
    await db.collection("hausdienst").doc(date).set({person, updatedAt:Date.now()});
    if(date===todayStr()) await updateTodayInfo();
    await renderNextDays(); await renderHistory();
  }
  function exists(d){ return d && d.exists; }
  async function clearSpecific(date){
    if(!db) return alert("Offline ‚Äì kann nicht l√∂schen.");
    await db.collection("hausdienst").doc(date).delete();
    if(date===todayStr()) await updateTodayInfo();
    await renderNextDays(); await renderHistory();
  }

  /* Heute + Liste */
  async function updateTodayInfo(){
    if(!db){ document.getElementById('todayInfo').textContent="Heute: (offline)"; return; }
    const d=await db.collection("hausdienst").doc(todayStr()).get();
    const person = exists(d) ? d.data().person : null;
    document.getElementById('todayInfo').innerHTML = person
      ? `Heute eingetragener Hausdienst: <span class="badge ok">${person}</span>`
      : `Heute: <span class="badge none">Noch niemand eingetragen</span>`;
  }

  async function renderNextDays(){
    if(!db){ document.getElementById('nextList').textContent="Offline ‚Äì keine Vorschau."; return; }
    const out=[];
    for(let i=0;i<14;i++){
      const dt=new Date(); dt.setDate(dt.getDate()+i);
      const id=dt.toISOString().slice(0,10);
      const doc=await db.collection("hausdienst").doc(id).get();
      out.push([id, exists(doc) ? (doc.data().person||null) : null, i===0]);
    }
    const rows = out.map(([d,p,isToday])=>{
      const action = p
        ? `<button class="btn small danger" onclick="clearSpecific('${d}')">Austragen</button>`
        : (selectedPerson ? `<button class="btn small" onclick="setForDate('${d}','${selectedPerson}')">Belegen mit Auswahl</button>` : `<span class="sub muted">frei</span>`);
      return `<tr><td>${isToday?d+" (heute)":d}</td><td>${p ? p : (selectedPerson ? `<span class="muted">‚Äì</span>` : "‚Äî")}</td><td style="text-align:right">${action}</td></tr>`;
    }).join("");
    document.getElementById('nextList').innerHTML = `<table><thead><tr><th>Datum</th><th>Person</th><th>Aktion</th></tr></thead><tbody>${rows}</tbody></table>`;
  }

  /* Checkliste */
  const CATS = [
    {key:"all",    label:"√úbersicht"},
    {key:"morgens",label:"Morgens"},
    {key:"tag",    label:"Im Laufe des Tages"},
    {key:"abend",  label:"Bevor man geht"},
  ];
  let showCat = localStorage.getItem("hausdienst_cat") || "all";
  let showMode= localStorage.getItem("hausdienst_filter_mode") || "open";

  const CHECKED_KEY="hausdienst_checked_"+todayStr();
  let checked = {};
  try { checked = JSON.parse(localStorage.getItem(CHECKED_KEY) || "{}"); } catch(_) { checked = {}; }

  let hideDone = localStorage.getItem("hausdienst_hideDone") === "true";

  function toggleHideDone() {
    hideDone = document.getElementById('hideDone').checked;
    localStorage.setItem("hausdienst_hideDone", hideDone);
    renderTasks();
  }

  // Legacy Funktionen (f√ºr Kompatibilit√§t)
  function setMode(m){ showMode = m; renderTasks(); }
  function setCat(cat){ showCat = cat; renderTasks(); }
  function renderCatTabs(){}

  function toggleCheck(id){
    checked[id] = !checked[id];
    localStorage.setItem(CHECKED_KEY, JSON.stringify(checked));
    renderTasks(); // re-render f√ºr Filter
    saveProgressToFirebase();
    checkAllTasksCompleted();
  }

  // Fortschritt in Firebase speichern f√ºr Anzeige in Strichliste
  async function saveProgressToFirebase() {
    if (!db || !todayPerson) return;
    const totalTasks = _tasks.length;
    const doneTasks = _tasks.filter(t => checked[t.id]).length;

    try {
      await db.collection("hausdienst").doc(todayStr()).set({
        taskProgress: { done: doneTasks, total: totalTasks }
      }, { merge: true });
    } catch(e) {
      console.error('Fehler beim Speichern des Fortschritts:', e);
    }
  }

  // Pr√ºfen ob alle Aufgaben erledigt und Pop-up anzeigen
  let completionPopupShown = false;
  function checkAllTasksCompleted() {
    if (completionPopupShown || hdTodayCompleted || !todayPerson) return;

    const totalTasks = _tasks.length;
    const doneTasks = _tasks.filter(t => checked[t.id]).length;

    if (doneTasks === totalTasks && totalTasks > 0) {
      completionPopupShown = true;
      showCompletionModal();
    }
  }

  async function addTask(){
    if(!db) return alert("Offline ‚Äì kann nicht speichern.");
    const inp=document.getElementById('newTask');
    const txt=inp.value.trim();
    if(!txt) return;

    // H√∂chsten sortOrder finden und +1 f√ºr neue Aufgabe
    const maxSortOrder = _tasks.length > 0 ? Math.max(..._tasks.map(t => t.sortOrder ?? 0)) : -1;

    await db.collection('hausdienst_tasks').add({
      text: txt,
      cat: 'tag',
      createdAt: Date.now(),
      sortOrder: maxSortOrder + 1
    });
    inp.value='';
    await renderTasks(true);
  }

  // Task bearbeiten
  let editingTaskId = null;

  function openEditTaskModal(taskId) {
    const task = _tasks.find(t => t.id === taskId);
    if (!task) return;

    editingTaskId = taskId;
    document.getElementById('editTaskText').value = task.text;
    document.getElementById('editTaskCat').value = task.cat || 'tag';
    document.getElementById('editTaskModal').classList.add('show');
  }

  function closeEditTaskModal() {
    document.getElementById('editTaskModal').classList.remove('show');
    editingTaskId = null;
  }

  async function saveTaskEdit() {
    if (!db || !editingTaskId) return;

    const text = document.getElementById('editTaskText').value.trim();
    const cat = document.getElementById('editTaskCat').value;

    if (!text) {
      alert('Bitte einen Text eingeben');
      return;
    }

    try {
      await db.collection('hausdienst_tasks').doc(editingTaskId).update({
        text: text,
        cat: cat,
        updatedAt: Date.now()
      });
      closeEditTaskModal();
      await renderTasks(true);
    } catch(e) {
      console.error('Fehler beim Speichern:', e);
      alert('Fehler beim Speichern');
    }
  }

  async function deleteTaskFromModal() {
    if (!editingTaskId) return;
    if (!confirm('Aufgabe wirklich l√∂schen?')) return;

    try {
      await db.collection('hausdienst_tasks').doc(editingTaskId).delete();
      closeEditTaskModal();
      await renderTasks(true);
    } catch(e) {
      console.error('Fehler beim L√∂schen:', e);
      alert('Fehler beim L√∂schen');
    }
  }

  async function deleteTask(id){
    if(!db) return alert("Offline ‚Äì kann nicht l√∂schen.");
    if(!confirm("Willst du diese Aufgabe wirklich l√∂schen?")) return;
    await db.collection('hausdienst_tasks').doc(id).delete();
    await renderTasks(true);
  }

  let _tasks = [];
  let draggedTaskId = null;

  async function loadTasks(){
    if(!db){ _tasks=[]; renderTasks(); return; }

    // Pr√ºfen, ob bereits Standardaufgaben vorhanden sind
    const snap = await db.collection('hausdienst_tasks').orderBy('sortOrder','asc').get();
    _tasks = snap.docs.map(d=>({id:d.id, ...d.data()}));

    // Fallback: sortieren nach createdAt wenn kein sortOrder vorhanden
    if (_tasks.length > 0 && _tasks[0].sortOrder === undefined) {
      const oldSnap = await db.collection('hausdienst_tasks').orderBy('createdAt','asc').get();
      _tasks = oldSnap.docs.map(d=>({id:d.id, ...d.data()}));
    }

    // Standardaufgaben nur hinzuf√ºgen, wenn noch keine Aufgaben vorhanden sind
    if (_tasks.length === 0) {
      // Standardaufgaben hinzuf√ºgen
      const defaultTasks = [
        { text: "Briefkasten leeren", cat: "morgens", createdAt: Date.now(), sortOrder: 0 },
        { text: "Sp√ºlmaschine ausr√§umen", cat: "morgens", createdAt: Date.now(), sortOrder: 1 },
        { text: "Toilettenpapier & Zewa auff√ºllen", cat: "morgens", createdAt: Date.now(), sortOrder: 2 },
        { text: "Getr√§nke auff√ºllen & Pfandkiste wechseln wenn voll", cat: "morgens", createdAt: Date.now(), sortOrder: 3 },
        { text: "Staubsauger Wasser checken", cat: "morgens", createdAt: Date.now(), sortOrder: 4 },
        { text: "Handt√ºcher im Bad wechseln", cat: "morgens", createdAt: Date.now(), sortOrder: 5 },
        { text: "W√§sche an machen & aufh√§ngen", cat: "tag", createdAt: Date.now(), sortOrder: 6 },
        { text: "Pakete entgegennehmen", cat: "tag", createdAt: Date.now(), sortOrder: 7 },
        { text: "F√ºr Grundordnung in Gemeinschaftsr√§umen sorgen", cat: "tag", createdAt: Date.now(), sortOrder: 8 },
        { text: "Oberfl√§chen in der K√ºche + Ger√§te wischen", cat: "abend", createdAt: Date.now(), sortOrder: 9 },
        { text: "Mikro & Backofen durchwischen", cat: "abend", createdAt: Date.now(), sortOrder: 10 },
        { text: "Haus- & Toiletten M√ºll rausbringen & mitnehmen", cat: "abend", createdAt: Date.now(), sortOrder: 11 }
      ];

      // Standardaufgaben zur Datenbank hinzuf√ºgen
      for (const task of defaultTasks) {
        await db.collection('hausdienst_tasks').add(task);
      }

      // Aufgaben neu laden
      const newSnap = await db.collection('hausdienst_tasks').orderBy('sortOrder','asc').get();
      _tasks = newSnap.docs.map(d=>({id:d.id, ...d.data()}));
    }
  }

  // Drag & Drop Funktionen (Desktop)
  function handleDragStart(e, taskId) {
    draggedTaskId = taskId;
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
  }

  function handleDragEnd(e) {
    e.target.classList.remove('dragging');
    document.querySelectorAll('.task-item').forEach(row => row.classList.remove('drag-over'));
    draggedTaskId = null;
  }

  function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    const row = e.target.closest('.task-item');
    if (row && !row.classList.contains('dragging')) {
      document.querySelectorAll('.task-item').forEach(r => r.classList.remove('drag-over'));
      row.classList.add('drag-over');
    }
  }

  function handleDragLeave(e) {
    const row = e.target.closest('.task-item');
    if (row) row.classList.remove('drag-over');
  }

  async function handleDrop(e, targetTaskId) {
    e.preventDefault();
    if (!draggedTaskId || draggedTaskId === targetTaskId) return;
    await reorderTasks(draggedTaskId, targetTaskId);
  }

  // Touch Drag & Drop (Mobile/Tablet)
  let touchDraggedRow = null;
  let touchDraggedTaskId = null;
  let touchStartX = 0;
  let touchStartY = 0;
  let touchCurrentY = 0;
  let longPressTimer = null;
  let isDragging = false;
  let scrollDetected = false;
  const LONG_PRESS_DURATION = 600; // 600ms f√ºr Long-Press (vorher 300ms)
  const SCROLL_THRESHOLD = 10; // Pixel Bewegung bevor als Scroll erkannt

  function handleTouchStart(e, taskId) {
    // Nur auf Drag-Handle reagieren f√ºr Touch-Drag
    const isDragHandle = e.target.closest('.drag-handle');
    if (!isDragHandle) return; // Normales Scrollen erlauben wenn nicht auf Handle

    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchDraggedTaskId = taskId;
    touchDraggedRow = e.target.closest('.task-item');
    scrollDetected = false;

    // Long-press zum Starten des Drag
    longPressTimer = setTimeout(() => {
      if (touchDraggedRow && !scrollDetected) {
        isDragging = true;
        touchDraggedRow.classList.add('touch-dragging');
        // Vibration f√ºr Feedback (falls unterst√ºtzt)
        if (navigator.vibrate) navigator.vibrate(50);
      }
    }, LONG_PRESS_DURATION);
  }

  function handleTouchMove(e) {
    // Wenn noch nicht im Drag-Modus, pr√ºfen ob gescrollt wird
    if (!isDragging) {
      if (touchDraggedRow && longPressTimer) {
        const touch = e.touches[0];
        const deltaX = Math.abs(touch.clientX - touchStartX);
        const deltaY = Math.abs(touch.clientY - touchStartY);

        // Wenn Bewegung erkannt, Long-Press abbrechen (User scrollt)
        if (deltaX > SCROLL_THRESHOLD || deltaY > SCROLL_THRESHOLD) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
          scrollDetected = true;
          touchDraggedRow = null;
          touchDraggedTaskId = null;
        }
      }
      return; // Normales Scrollen erlauben
    }

    // Im Drag-Modus: Scrollen verhindern
    e.preventDefault();
    const touch = e.touches[0];
    touchCurrentY = touch.clientY;

    // Finde das Element unter dem Finger
    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    const rowBelow = elementBelow?.closest('.task-item');

    // Highlight des Ziel-Elements
    document.querySelectorAll('.task-item').forEach(r => r.classList.remove('drag-over'));
    if (rowBelow && rowBelow !== touchDraggedRow) {
      rowBelow.classList.add('drag-over');
    }
  }

  async function handleTouchEnd(e) {
    clearTimeout(longPressTimer);
    longPressTimer = null;

    if (!isDragging) {
      touchDraggedRow = null;
      touchDraggedTaskId = null;
      scrollDetected = false;
      return;
    }

    // Finde das Ziel-Element
    const touch = e.changedTouches[0];
    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    const rowBelow = elementBelow?.closest('.task-item');
    const targetTaskId = rowBelow?.dataset?.taskid;

    // Aufr√§umen
    if (touchDraggedRow) touchDraggedRow.classList.remove('touch-dragging');
    document.querySelectorAll('.task-item').forEach(r => r.classList.remove('drag-over'));

    // Neu ordnen wenn g√ºltiges Ziel
    if (targetTaskId && targetTaskId !== touchDraggedTaskId) {
      await reorderTasks(touchDraggedTaskId, targetTaskId);
    }

    touchDraggedRow = null;
    touchDraggedTaskId = null;
    isDragging = false;
    scrollDetected = false;
  }

  // Gemeinsame Funktion zum Neuordnen
  async function reorderTasks(fromTaskId, toTaskId) {
    const draggedIndex = _tasks.findIndex(t => t.id === fromTaskId);
    const targetIndex = _tasks.findIndex(t => t.id === toTaskId);
    if (draggedIndex === -1 || targetIndex === -1) return;

    // Array neu ordnen
    const [moved] = _tasks.splice(draggedIndex, 1);
    _tasks.splice(targetIndex, 0, moved);

    // sortOrder in Firebase aktualisieren
    const batch = db.batch();
    _tasks.forEach((task, index) => {
      const ref = db.collection('hausdienst_tasks').doc(task.id);
      batch.update(ref, { sortOrder: index });
      task.sortOrder = index;
    });
    await batch.commit();

    renderTasks();
  }

  function filteredTasks(){
    let arr = [..._tasks];
    if (hideDone) arr = arr.filter(t => !checked[t.id]);
    return arr;
  }

  const catLabels = { morgens: '‚òÄÔ∏è Morgens', tag: 'üìã Im Laufe des Tages', abend: 'üåô Bevor man geht' };
  const catOrder = ['morgens', 'tag', 'abend'];

  async function renderTasks(reload=false){
    if(reload) await loadTasks();
    const list = document.getElementById('taskList');
    const arr = filteredTasks();

    // Checkbox-Status setzen
    const hideCheckbox = document.getElementById('hideDone');
    if (hideCheckbox) hideCheckbox.checked = hideDone;

    if(!arr.length){
      list.innerHTML = `<div style="padding:30px;text-align:center;opacity:0.5">${hideDone ? 'Alle Aufgaben erledigt!' : 'Keine Aufgaben vorhanden'}</div>`;
      updateStatusHeader();
      saveProgressToFirebase();
      return;
    }

    // Nach Kategorie gruppieren
    const grouped = {};
    catOrder.forEach(cat => grouped[cat] = []);
    arr.forEach(t => {
      const cat = t.cat || 'tag';
      if (!grouped[cat]) grouped[cat] = [];
      grouped[cat].push(t);
    });

    let html = '';
    catOrder.forEach(cat => {
      const tasks = grouped[cat];
      if (tasks.length === 0) return;

      html += `<div class="task-group" data-cat="${cat}">`;
      html += `<div class="task-group-header">${catLabels[cat]}</div>`;

      tasks.forEach(t => {
        const isDone = !!checked[t.id];
        html += `
          <div class="task-item ${isDone ? 'done' : ''}" data-taskid="${t.id}" draggable="true"
            ondragstart="handleDragStart(event, '${t.id}')"
            ondragend="handleDragEnd(event)"
            ondragover="handleDragOver(event)"
            ondragleave="handleDragLeave(event)"
            ondrop="handleDrop(event, '${t.id}')"
            ontouchstart="handleTouchStart(event, '${t.id}')"
            ontouchmove="handleTouchMove(event)"
            ontouchend="handleTouchEnd(event)">
            <span class="drag-handle">‚†ø</span>
            <div class="task-checkbox ${isDone ? 'checked' : ''}" onclick="event.stopPropagation(); toggleCheck('${t.id}')"></div>
            <div class="task-content" onclick="toggleCheck('${t.id}')">
              <div class="task-text">${t.text}</div>
            </div>
            <div class="task-actions">
              <button class="task-action-btn" onclick="event.stopPropagation(); openEditTaskModal('${t.id}')" title="Bearbeiten">‚úèÔ∏è</button>
            </div>
          </div>
        `;
      });

      html += `</div>`;
    });

    list.innerHTML = html;
    updateStatusHeader();
    saveProgressToFirebase();
  }

  function updateStatusHeader() {
    const totalTasks = _tasks.length;
    const doneTasks = _tasks.filter(t => checked[t.id]).length;
    const progress = totalTasks > 0 ? Math.round((doneTasks / totalTasks) * 100) : 0;
    const allDone = doneTasks === totalTasks && totalTasks > 0;

    // Person und Datum
    const personEl = document.getElementById('hdPersonName');
    const dateEl = document.getElementById('hdDate');
    if (personEl) {
      if (todayPerson) {
        personEl.textContent = todayPerson;
        personEl.classList.remove('none');
      } else {
        personEl.textContent = 'Kein Hausdienst eingetragen';
        personEl.classList.add('none');
      }
    }
    if (dateEl) {
      const today = new Date();
      dateEl.textContent = today.toLocaleDateString('de-DE', { weekday: 'long', day: 'numeric', month: 'long' });
    }

    // Progress Ring
    const ringFill = document.getElementById('ringFill');
    const progressText = document.getElementById('progressText');
    const progressRing = document.getElementById('progressRing');
    if (ringFill) ringFill.setAttribute('stroke-dasharray', `${progress}, 100`);
    if (progressText) progressText.textContent = `${doneTasks}/${totalTasks}`;
    if (progressRing) progressRing.classList.toggle('done', allDone || hdTodayCompleted);

    // Complete Button
    const completeBtn = document.getElementById('completeHdBtn');
    if (completeBtn) {
      if (hdTodayCompleted) {
        completeBtn.textContent = '‚úì Abgeschlossen';
        completeBtn.disabled = true;
        completeBtn.classList.add('done');
      } else if (allDone && todayPerson) {
        completeBtn.textContent = '‚úì Hausdienst abschlie√üen';
        completeBtn.disabled = false;
        completeBtn.classList.remove('done');
      } else {
        completeBtn.textContent = `Noch ${totalTasks - doneTasks} Aufgaben offen`;
        completeBtn.disabled = true;
        completeBtn.classList.remove('done');
      }

      // Verstecken wenn kein Hausdienst
      completeBtn.style.display = todayPerson ? 'block' : 'none';
    }

    // Rating Card anzeigen wenn gestern jemand Hausdienst hatte
    const ratingCard = document.getElementById('ratingCard');
    if (ratingCard) {
      ratingCard.style.display = (yesterdayPerson && todayPerson) ? 'block' : 'none';
    }
  }

  /* Bewertungssystem */
  let modalRating = 0;
  let yesterdayPerson = null;
  let todayPerson = null;
  let hdTodayCompleted = false; // Ob der heutige Hausdienst abgeschlossen ist
  let existingRatingId = null; // ID der bestehenden Bewertung
  let existingRatingData = null; // Daten der bestehenden Bewertung

  function getYesterdayStr() {
    const d = new Date();
    d.setDate(d.getDate() - 1);
    return d.toISOString().slice(0, 10);
  }

  // Modal Funktionen
  function hoverModalRating(val) {
    const stars = document.querySelectorAll('#modalStars .star');
    stars.forEach((star, i) => {
      star.classList.toggle('hovered', i < val);
    });
  }

  function setModalRating(val) {
    modalRating = val;
    const stars = document.querySelectorAll('#modalStars .star');
    stars.forEach((star, i) => {
      star.classList.toggle('active', i < val);
    });
    document.getElementById('modalSubmitBtn').disabled = modalRating === 0;
  }

  async function openRatingModal() {
    if (!yesterdayPerson || !todayPerson) return;

    // Bestehende Bewertung laden
    const existingRating = await db.collection('bewertungen')
      .where('date', '==', getYesterdayStr())
      .where('bewertetVon', '==', todayPerson)
      .get();

    if (!existingRating.empty) {
      existingRatingId = existingRating.docs[0].id;
      existingRatingData = existingRating.docs[0].data();
      setModalRating(existingRatingData.rating);
      document.getElementById('modalComment').value = existingRatingData.comment || '';
      document.getElementById('modalRatingInfo').innerHTML =
        `Bewertung f√ºr <b>${yesterdayPerson}</b> (${getYesterdayStr()}) bearbeiten:`;
      document.getElementById('modalSubmitBtn').textContent = 'Aktualisieren';
    } else {
      existingRatingId = null;
      existingRatingData = null;
      modalRating = 0;
      document.querySelectorAll('#modalStars .star').forEach(s => s.classList.remove('active', 'hovered'));
      document.getElementById('modalComment').value = '';
      document.getElementById('modalSubmitBtn').disabled = true;
      document.getElementById('modalRatingInfo').innerHTML =
        `Bewerte den Hausdienst von <b>${yesterdayPerson}</b> (${getYesterdayStr()}):`;
      document.getElementById('modalSubmitBtn').textContent = 'Bewerten';
    }

    document.getElementById('ratingModal').classList.add('show');
  }

  function closeRatingModal() {
    document.getElementById('ratingModal').classList.remove('show');
  }

  async function submitModalRating() {
    if (!db || modalRating === 0 || !yesterdayPerson || !todayPerson) return;

    const comment = document.getElementById('modalComment').value.trim();

    if (existingRatingId) {
      // Bestehende Bewertung aktualisieren
      await db.collection('bewertungen').doc(existingRatingId).update({
        rating: modalRating,
        comment: comment,
        updatedAt: Date.now()
      });
      alert('Bewertung aktualisiert!');
    } else {
      // Neue Bewertung erstellen
      await db.collection('bewertungen').add({
        date: getYesterdayStr(),
        bewerteterHausdienst: yesterdayPerson,
        bewertetVon: todayPerson,
        rating: modalRating,
        comment: comment,
        createdAt: Date.now()
      });
      alert('Bewertung gespeichert!');
    }

    existingRatingData = { rating: modalRating, comment: comment };
    closeRatingModal();
    updateHdStatus();
  }

  async function checkAndShowRatingModal() {
    if (!db) return;

    // Heute und Gestern laden
    const todayDoc = await db.collection('hausdienst').doc(todayStr()).get();
    const yesterdayDoc = await db.collection('hausdienst').doc(getYesterdayStr()).get();

    todayPerson = todayDoc.exists ? todayDoc.data().person : null;
    hdTodayCompleted = todayDoc.exists ? (todayDoc.data().completed || false) : false;
    yesterdayPerson = yesterdayDoc.exists ? yesterdayDoc.data().person : null;

    if (!todayPerson || !yesterdayPerson) {
      updateHdStatus();
      return;
    }

    // Pr√ºfen ob bereits bewertet
    const existingRating = await db.collection('bewertungen')
      .where('date', '==', getYesterdayStr())
      .where('bewertetVon', '==', todayPerson)
      .get();

    const hasRating = !existingRating.empty;
    if (hasRating) {
      existingRatingId = existingRating.docs[0].id;
      existingRatingData = existingRating.docs[0].data();
    } else {
      existingRatingId = null;
      existingRatingData = null;
    }

    updateHdStatus();

    // Modal automatisch √∂ffnen wenn noch nicht bewertet
    if (!hasRating) {
      openRatingModal();
    }
  }

  // Alias f√ºr Kompatibilit√§t
  function updateHdStatus() {
    updateStatusHeader();
  }

  // Hausdienst als abgeschlossen markieren
  async function completeHausdienst() {
    if (!db || !todayPerson) return;

    const totalTasks = _tasks.length;
    const doneTasks = _tasks.filter(t => checked[t.id]).length;

    if (doneTasks < totalTasks) {
      alert('Es sind noch nicht alle Aufgaben erledigt!');
      return;
    }

    if (!confirm(`Hausdienst als abgeschlossen markieren?\n\nAlle ${totalTasks} Aufgaben wurden erledigt.`)) {
      return;
    }

    await markHausdienstComplete();
  }

  // Gemeinsame Funktion zum Abschlie√üen
  async function markHausdienstComplete() {
    try {
      await db.collection("hausdienst").doc(todayStr()).set({
        completed: true,
        completedAt: Date.now()
      }, { merge: true });

      hdTodayCompleted = true;
      updateHdStatus();
      showPlanNextModal();
    } catch (e) {
      console.error('Fehler beim Abschlie√üen:', e);
      alert('Fehler beim Abschlie√üen des Hausdienstes.');
    }
  }

  // Abschluss-Modal Funktionen
  function showCompletionModal() {
    document.getElementById('completionModal').classList.add('show');
  }

  function closeCompletionModal() {
    document.getElementById('completionModal').classList.remove('show');
  }

  async function confirmCompletion() {
    closeCompletionModal();
    await markHausdienstComplete();
  }

  // Planungs-Modal f√ºr n√§chsten Tag
  function getTomorrowStr() {
    const d = new Date();
    d.setDate(d.getDate() + 1);
    return d.toISOString().slice(0, 10);
  }

  async function showPlanNextModal() {
    // Pr√ºfen ob morgen schon jemand eingetragen ist
    const tomorrowDoc = await db.collection('hausdienst').doc(getTomorrowStr()).get();
    if (tomorrowDoc.exists && tomorrowDoc.data().person) {
      const person = tomorrowDoc.data().person;
      alert(`‚úì Hausdienst abgeschlossen!\n\nMorgen ist bereits ${person} eingetragen.`);
      return;
    }

    // Personen-Auswahl rendern
    const container = document.getElementById('planNextPeopleList');
    container.innerHTML = CORE.map(p => `
      <button class="pill" onclick="planNextPerson('${p}')">${p}</button>
    `).join('');

    document.getElementById('planNextModal').classList.add('show');
  }

  function closePlanNextModal() {
    document.getElementById('planNextModal').classList.remove('show');
    alert('‚úì Hausdienst erfolgreich abgeschlossen!');
  }

  async function planNextPerson(person) {
    try {
      await db.collection("hausdienst").doc(getTomorrowStr()).set({
        person: person,
        updatedAt: Date.now()
      });
      document.getElementById('planNextModal').classList.remove('show');
      alert(`‚úì Hausdienst abgeschlossen!\n\n${person} ist jetzt f√ºr morgen eingetragen.`);
      await renderNextDays();
    } catch(e) {
      console.error('Fehler beim Planen:', e);
      alert('Fehler beim Eintragen f√ºr morgen.');
    }
  }

  /* 6-Monats-√úbersicht */
  async function renderMonthlyOverview() {
    if (!db) return;

    const table = document.getElementById('monthlyOverview');
    if (!table) return;

    // Letzte 6 Monate berechnen
    const months = [];
    for (let i = 0; i < 6; i++) {
      const d = new Date();
      d.setMonth(d.getMonth() - i);
      months.push(d.toISOString().slice(0, 7)); // YYYY-MM
    }

    // Alle Hausdienste der letzten 6 Monate laden
    const firstMonth = months[months.length - 1];
    const lastMonth = months[0];
    const snap = await db.collection("hausdienst")
      .where(firebase.firestore.FieldPath.documentId(), ">=", firstMonth + "-01")
      .where(firebase.firestore.FieldPath.documentId(), "<=", lastMonth + "-31")
      .get();

    // Daten pro Person und Monat aggregieren
    const data = {}; // { "YYYY-MM": { "Person": count } }
    months.forEach(m => data[m] = {});
    CORE.forEach(p => months.forEach(m => data[m][p] = 0));

    snap.forEach(doc => {
      const person = doc.data().person;
      if (!person || !CORE.includes(person)) return;

      const month = doc.id.slice(0, 7);
      if (!data[month]) return;

      // Wochenende = 0.5, Wochentag = 1
      const date = new Date(doc.id);
      const dayOfWeek = date.getDay();
      const isWeekend = (dayOfWeek === 0 || dayOfWeek === 6);
      const points = isWeekend ? 0.5 : 1;

      data[month][person] = (data[month][person] || 0) + points;
    });

    // Summen pro Person berechnen
    const totals = {};
    CORE.forEach(p => {
      totals[p] = months.reduce((sum, m) => sum + (data[m][p] || 0), 0);
    });

    // Tabelle rendern
    const monthNames = ['Jan', 'Feb', 'M√§r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];

    let headerHtml = '<tr><th>Monat</th>';
    CORE.forEach(p => headerHtml += `<th>${p}</th>`);
    headerHtml += '</tr>';

    let bodyHtml = '';
    months.forEach(m => {
      const [year, month] = m.split('-');
      const monthName = monthNames[parseInt(month) - 1];
      bodyHtml += `<tr><td>${monthName} ${year}</td>`;
      CORE.forEach(p => {
        const count = data[m][p] || 0;
        let cellClass = 'count-cell';
        if (count === 0) cellClass += ' zero';
        else if (count >= 3) cellClass += ' good';
        else if (count >= 2) cellClass += ' warn';
        else cellClass += ' bad';
        bodyHtml += `<td class="${cellClass}">${count % 1 === 0 ? count : count.toFixed(1)}</td>`;
      });
      bodyHtml += '</tr>';
    });

    // Summen-Zeile
    let footerHtml = '<tr><td>Gesamt</td>';
    CORE.forEach(p => {
      const total = totals[p];
      footerHtml += `<td class="count-cell">${total % 1 === 0 ? total : total.toFixed(1)}</td>`;
    });
    footerHtml += '</tr>';

    table.innerHTML = `<thead>${headerHtml}</thead><tbody>${bodyHtml}</tbody><tfoot>${footerHtml}</tfoot>`;
  }

  /* Historie (letzte 30 Tage) */
  async function renderHistory(){
    const el = document.getElementById('histList');
    if(!db){ el.textContent="Offline ‚Äì keine Historie."; return; }

    // Bewertungen laden
    const bewertungenSnap = await db.collection('bewertungen').get();
    const bewertungen = {};
    bewertungenSnap.forEach(doc => {
      const data = doc.data();
      bewertungen[data.date] = data;
    });

    const rows=[];
    for(let i=0;i<30;i++){
      const dt=new Date(); dt.setDate(dt.getDate()-i);
      const id=dt.toISOString().slice(0,10);
      const doc=await db.collection("hausdienst").doc(id).get();
      const data = exists(doc) ? doc.data() : null;
      const person = data ? (data.person||'‚Äî') : '‚Äî';
      const completed = data?.completed || false;
      const bewertung = bewertungen[id];

      let statusBadge = '';
      if (person !== '‚Äî') {
        statusBadge = completed
          ? '<span class="badge ok">‚úì</span>'
          : '<span class="badge" style="background:#ff6b6b;color:#fff">‚óã</span>';
      }

      let ratingHtml = '‚Äî';
      if (bewertung) {
        const stars = '‚òÖ'.repeat(bewertung.rating) + '<span style="opacity:0.3">' + '‚òÖ'.repeat(5 - bewertung.rating) + '</span>';
        ratingHtml = `<span style="color:#ffd700">${stars}</span>`;
      }

      rows.push(`<tr><td>${id}</td><td>${person} ${statusBadge}</td><td>${ratingHtml}</td></tr>`);
    }
    el.innerHTML = `<table><thead><tr><th>Datum</th><th>Person</th><th>Bewertung</th></tr></thead><tbody>${rows.join('')}</tbody></table>`;
  }

  /* Initialisierung */
  async function init(){
    // Kernteam aus Firebase laden
    if(db) {
      try {
        const snap = await db.collection(STATE_COLLECTION).doc("global").get();
        if(snap.exists && snap.data().core && Array.isArray(snap.data().core)) {
          CORE = snap.data().core;
        }
      } catch(e) { console.error('Fehler beim Laden des Kernteams:', e); }
    }

    // Hausdienst-Daten ZUERST laden (vor renderTasks)
    if (db) {
      const todayDoc = await db.collection('hausdienst').doc(todayStr()).get();
      const yesterdayDoc = await db.collection('hausdienst').doc(getYesterdayStr()).get();
      todayPerson = todayDoc.exists ? todayDoc.data().person : null;
      hdTodayCompleted = todayDoc.exists ? (todayDoc.data().completed || false) : false;
      yesterdayPerson = yesterdayDoc.exists ? yesterdayDoc.data().person : null;
    }

    renderPeopleRow();
    updateSelectionUI();
    setMode(showMode);
    renderCatTabs();
    await loadTasks();
    await Promise.all([updateTodayInfo(), renderNextDays(), renderTasks(), renderHistory(), renderMonthlyOverview()]);

    // Bewertungsdaten laden
    if (db) {
      if (todayPerson && yesterdayPerson) {
        const existingRating = await db.collection('bewertungen')
          .where('date', '==', getYesterdayStr())
          .where('bewertetVon', '==', todayPerson)
          .get();
        if (!existingRating.empty) {
          existingRatingId = existingRating.docs[0].id;
          existingRatingData = existingRating.docs[0].data();
        }
      }
      updateHdStatus();
    }

    // Tab ausw√§hlen (nach dem Laden der Daten)
    pickTabFromQuery();

    scheduleMidnightRefresh(async ()=>{
      localStorage.removeItem(CHECKED_KEY);
      checked={};
      modalRating = 0;
      existingRatingId = null;
      existingRatingData = null;
      todayPerson = null;
      hdTodayCompleted = false;
      yesterdayPerson = null;
      await updateTodayInfo();
      await renderTasks(true);
      await renderNextDays();
      renderHistory();
      updateHdStatus();
    });
  }
  init();
</script>

<!-- ‚úÖ Service Worker Registrierung -->
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js?v=21', { scope: './' })
      .catch(() => {});
  }
</script>
</body>
</html>
